import java.util.Scanner;
import java.util.*;
import java.util.Stack;

public class Main {
   // Stack<Character> stack = new Stack<Character>();
    public static void main(String[] args) {
        LList<Integer> a = new SingleLinkedList<>();
        a.addFirst(3);
        a.addFirst(4);
        a.addFirst(5);
        a.print();
        //a.createLoop(1);
        //System.out.println(a.findLoopStart());
        //a.print();
        a.addFirst(3);
        a.print();
        System.out.println(a.isEmpty());
        a.addFirst(6);
        a.addFirst(5);
        a.addFirst(4);
        a.addFirst(3);
        a.addFirst(2);
        a.addFirst(1);
        a.addFirst(0);
        a.print();
        System.out.println("5 с конца элемент == " + a.dz());
        a.addFirst(4);
        a.print();
        a.removeFirst(4);
        a.print();
        System.out.println(a.isEmpty());
        a.addFirst(2);
        a.addLast(2);
        a.addFirst(3);
        a.addFirst(2);
        a.addFirst(6);
        a.addFirst(2);
        a.print();
        a.removeAll(2);
        a.print();
        a.removeFirst(6);
        a.print();

        LList<Integer> b = new DoubleLinkedList<>();

        b.print();
        b.addFirst(1);
        b.print();
        b.addLast(3);
        b.addLast(3);
        b.addLast(3);
        b.print();
        b.addFirst(3);
        b.print();
        b.addLast(4);
        b.print();

        b.addLast(4);
        b.addLast(4);
        b.addLast(4);
        b.addLast(3);
        b.addLast(4);
        b.addFirst(4);
        b.print();
        b.removeFirst(4);
        b.print();
        b.removeAll(4);
        b.print();
        System.out.println();

        LList<String> s = new SingleLinkedList<>();
        s.addFirst("asdad");
        s.addFirst("asd");
        s.addFirst("aad");
        s.addLast("3sda3");
        s.print();

        SQ<Character> stack = new STACK<Character>();
        System.out.println("Вводим строку для проверки на баланс скобок: ");
        Scanner scan = new Scanner(System.in);
        String st = scan.nextLine();

        int k = 0;
        for (int i = 0; i < st.length(); i++)
        {
            if (st.charAt(i) == '(' || st.charAt(i) == '{' || st.charAt(i) == '[' ) {
                stack.push(st.charAt(i));
            }

            else if(st.charAt(i) == ')') {
                if(!stack.isEmpty() && stack.peek() == '(') stack.pop();
                else
                {
                    System.out.print("Не соблюден баланс скобок");
                    return;
                }
            } else if (st.charAt(i) == ']') {
                if(!stack.isEmpty() && stack.peek() == '[') stack.pop();
                else
                {
                    System.out.print("Не соблюден баланс скобок");
                    return;
                }
            } else if(st.charAt(i) == '}'){
                if(!stack.isEmpty() && stack.peek() == '{') stack.pop();
                 else
                {
                    System.out.print("Не соблюден баланс скобок");
                    return;
                }
            }

        }
        if(stack.isEmpty())
        {
            System.out.print("Соблюден баланс скобок");
        }
        else
        {
            System.out.print("Не соблюден баланс скобок");
        }
        System.out.println();
        SQ<Integer> q = new Queue<>();
        q.push(11);
        q.push(14);
        q.push(19);
        q.print();
        System.out.println(q.peek());
        q.pop();
        System.out.println(q.peek());
        q.print();


    }

}






//практика программирования на с++ кергиган

/* алгоритм зайца и черепахи
решение задачи с кольцом:
есть связ список
создаем 2 указателя
1 из них пускаем с обычной скоростью
2 - пускаем со скоростью в 2 раза больше
если 1 и 2 указывют на 1 и тот же узел то есть кольцо
ДЗ найти с какого элемента начинается кольцо

Stack:
с помощью линкед лист
методы pop
       push(T value)
       peak() посмотреть элемент в списке, не извлекая его

Queue:
линейный связ двунаправленный список
методы enqueue
       dequeue
       print

Рекурсия:
3 вида рекурсии:
1) прямая - вызов функции с другими параметрами
2) косвеная - А вызывает функцию В; В вызывает А
3) хвостовая - после н итераций, на н+1 вызывает
рекурсию можно заменить на итерационный алгоритм
в рекурсии есть прямой и обратный ход


int factorial(int n)
{
    if (n==1) return 1; - приводит к тривиальному случаю
    return n * factorial(n-1); - измененный набор параметров - должна приводить к тривиальному случаю
}
количество вызовов рекурсии - глубина рекурсии
компиляторы умеют разворачивать рекурсивный алгоритм в итерационный

Ханойские башни
void hanoi(int n(kolvo kolec), int source(sterzhen s kotorogo perenosim),int target(sterzhen kuda perenosim),int c(vspomogatelni sterzhen))
//print(n: 1-->2)
//print(n,1,3,2) перенос n-ого кольца с кольца 1 на кольцо 3 используя кольцо 2
hanoi(n-1, source, c, target);
print(n: source, target,
hanoi(n-1, c, target, source);


tree
add(map, key, value) 0(1)(add first) 0(n)(find position)
lookup(map, key) 0(n) 0(n)
remove(map,key) 0(n) 0(n)
min(map) 0(n) 0(1)
max(map)

упорядоченный словарь - словарь обеспечивающий перебор элементов в упорядоченной послед-сти
операции Prev(key) Next(key)

class TreeNode
{
int key;
T data;//dannie sootv kluchu
TreeNode left;
TreeNode right;
}
40-58-20-6-3-90-50-35-100
class TreeNode
{
TreeNode root;
TreeNode min()
{
if (root == NULL) return NULL;
var tmp = root;
while (tmp.left != NULL)
    {
    tmp = tmp.left;
    }
}
return tmp;
}
void add(int key)
{
var newNode == new newNode(key);
    if (root == NULL)
    {
    root = newNode;
    return;
    }
    else
    {
    tmp = root;
    while (tmp.left !=NULL || tmp.right != NULL)
    if (tmp.key > key)
    {
    tmp = tmp.left;
    }
    else if (tmp.key <key)
    {
    tmp = tmp.right;
    }
    else
    {
    throw new RuntimeException();
    }

    }
}
//node = Min(map)





30.03
словарь - структура данных для хранения пар вида ключ-значение

хеш таблица - структура данных для хранения пар ключ-значение
поиск, добавление удаление за 0(1) - не зависит от длины массива
float double char нельзя использовать как индекс
коэффициент заполнения хеш-таблицы (load factor) - отношение n хранимых элементов в хеш-таблицы к размеру массива h
от коэффициента зависит время поиска добавления и удаления элементов

хеш-функция - функция преобразует значение ключа в целое число
хеш-код это возвращаемое значение функции
коллизия - совпадение значений хеш-функции для 2 разных ключей

метод цепочек - закрытая адрсация:
при коллизии элемент добавляется в начало
поиск и удаление требуют просмотра всего списка

метод открытой адресации
в ячейках хранятся не указатель на связный список, а 1 элемент
линейное хеширование - проверяются позиции hash(key)+1 hash(key) + 2, ... , (hash(key) + i) mod h
//хорстман алгоритмы и анализ
быстрое вычисление хеш кода
детерминирование - для заданного ключа должна возвращать 1 и то же значение
если объекты равны то хеш-код равен, но не наоборот


ДЗ примеры хеш-функций + где применяются

равномерность - хеш-функция должна равномерно  заполнять индексы массива возвращаемыми номерами
строки в джаве неизменяемы
хеш-таблица ОЧЕНЬ КРУТАЯ!!!!!
ДЛИНА ХЕШ-ТАБЛИЦЫ - ПРОСТОЕ ЧИСЛО


06.04.23
граф - совокупность непустого множетсва V вершин и множества E ребер
//SAAD численные методы решения СЛАУ
путь - последовательность вершин, в которой следующая вершина является смежной с предыдущей
путь в ориентированных - маршрут

цикл - путь в котором первая и последняя вершины совпадают
степень вершины - количество ребер которые инцидентны вершине (сколько ребер из вершины)
связный граф - граф в котором существует путь из каждой вершины в любую другую
взвешенный граф - граф, ребрами которого назначены веса
полный граф - граф, в котором каждая пара различных вершин смежна (каждая вершина соединена со всеми)
количество ребер в неоринтированном графе m = n(n-1)/2
насыщенность графа d = 2m / (n(n-1))
у полного графа насыщенность  == 1
насыщенный граф - это граф, в котором количество ребер близко к максимально возможному
разреженный граф - граф, в котором количество ребер близко к минимальному

представлене графов в памяти:
матрица смежности - для насыщенных графов
списки смежных вершин - для разреженных графов
списки смежных вершин - это массив A[n], каждый элемент A[i] которого содержит список узлов смежных с вершиной i

обход графа - процедура перебора (посещения) всех вершин начиная с заданной
поиск в глубину - процедура посещения всех вершин графа начиная с заданного узла v
методы:
поиск в глубину-список смежности и матрицы смежности

поиск в ширину - процедура посещения всех вершин графа начиная с заданного узла v
(сперва посещаем свои дочерние вершины)

поиск кратчайшего пути в графе
кратчайший путь - путь, сумма весов которого, минимальна
постановки задачи:
между парой вершин
между заданной вершиной до всех остальных
между всеми вершинами до заданной
между каждой до каждой

Алгоритмы:
Дейкстры
Беллмана-Форда
А star
Флойда-Уоршелла
Джонсона
Ли

//Тим Рафгардан совершенный алгоритм
Дейкстра
h - множество песещенных вершин
d[i] - текущее известное кратчайшее расстояние от вершины s до вершины i
prev[i] - номер вершины, предшествующей i  в пути


13/04/23
сбалансирвоанные деревья
красно-черные деревья
каждый узел имеет не более 2 дочерных узлов
каждый узел имеет
//Jpoint
трудоемкость пропорциональна высоте дерева
в среднем случае высота дерева 0(лог(н))
Сбалансированные деревья:
красно-черные деревья
АА-деревья
В-деревья
2-3-деревья
авл-деревья
Add(key, value)
lookup(key)
remove(key)
min
max

черная высота -  количество черных узлов на пути узла х до листа - черная высота его корня
красно-черное дерево с n внутренними узлами имеет высоту <= 2log2(n+1)

структура узла дерева
node.parent - указатель на родительский корень
node.left - указатель на левый дочерний узел
node.right - указатель на правый дочерний узел
node.color - цвет узла
T.root - указатель на корень дерева

Для удобства все листья - указатели на 1 и тот же ограничивающий узел черного цвета T.null
Доавление элоемента:
1) находим лист для вставки нового элемента
2) создаем элемент и окрашиваем уго в красный цвет
3) перекрашиваем узлы и поворачиваем

удаление:
1) по ключу находим элемент для уаления
2)


27.04.23
Сбалансированные деревья
в каждом узле дерева надо что-то хранить

AVL деревья - сбалансированные по высоте двоичные деревья поиска, в котором у любой выршины высота левого и правого поддеревьев отличаются не более чер на 1
идея: если вставка или удаление элемента приводит к нарушению сбалансированности дерева, то надо сбалансировать
коэффициент сбалансированности узла - разность высот левого и правого поддеревьев (в AVL он может быть из {-1,0,1})
высота узла - длина наибольшего пути
после добавления необходимо обновить коэфф сбалансированности родительских узлов
если любой родительский узел принял значение -2 или 2, то надо выполнить балансировку поддерева путем поворота
повороты:
1) одиночный правый поворот
2) одиночный левый поворот
3) двойной лево-правый поворот
4) двойной право-левый поворот
Повороты за о(1)
любой поворот сохраняет свойства бинарного дерева
высота дерева h = O(log(n+2))

Префиксные деревья - структура данных для реализации множества\словаря, ключи которого - только строки
предиктивный ввод текста
ключ - набор символов из алфавита
каждый узел содержит от 1 до d узлов
значения хранятся в листьях
ключи не хранятся в узлах дерева
позиция листа в дереве определяется значением ключа
(префиксное дерево для телефонной книги - для баллов)
приемущества:
1) время поиска не зависит от количества элементов в словаре
2) для хранения ключей не используются дополнительной памяти
3) в отличие от хеш-таблиц



04.05.23
основные методы разработки алгоритмов:
1) метод грубой силы (полный перебор)
2) декомпозиция (разделяй и властвуй)
3) уменьшение размера задачи
4) преобразование
5) жадные алгоритмы
6) динамическое программирование
7) поиск с возвратом
8) локальный поиск

Грубая сила:
пример 1) метод грубой силы (решение в лоб) возведение числа в неотриц степень a**n = a * a * a * ... * a
грубая сила: умножение матриц, поиск min max в списке, сортировка пузырьком и выбором, поиск подстроки в строке, перебор пары точек на плоскости

Декомпозиция:
1) задача разделяется на несколько меньших экземпляров задач
2) решаются меньшие экземпляры задачи(обычно рекурсивно)
3) при необходимости решение задачи формируется как комбинация решений меньших задач
пример: бинарный поиск, рекурсивное возведение в степень
время работы алгоритма T(n) = aT(n/b) + f(n) (f(n) -  время на разделдение)
рекуррентное соотношение - обобщенное рекуррентное уравнение декомпозиции
пример: сортировка слиянием и быстрая, бинарный поиск, обход бин дерева, выпуклая оболочка, поиск пары ближайших точек, умножение матриц методом Штрассена
У быстрой сортировки есть минус - может поменять равные элементы
устойчивая сортировка сохраняет порядок элементов при сортировке согласно исходному (этим обладаем сорт слиянием - имба(в готовых библиотеках) - ее время O(n log n)

Динамическое приграммирование:
разбиение задач на подзадачи
идея - запоминать решения встречающихся подзадач, если она повторится
пример: вычислить n-ый член Фибоначчи
в динамическои программировании используются таблицы, в которых сохраняются решения подзадач(жертвуем памятью ради времени)

Жадные алгоритмы:
жадный алгоритм - алгоритм, который принимает на каждом шаге локально-оптимальное решение
пример: алгоритмы Прима, Дейкстры, Крускала
задача о размене монет, код Хаффмана

Поиск с возвратом:
поиск с возвратом - метод решения задач, в которых необходим полный перебор всех возможных вариантов в некотором множестве
примеры: коммивояжёра, подбор пароля, задача о восьми ферзях (92 варианта), задача о ранце, раскраска карты, поиск выхода из лабиринта

Локальный поиск


DSA SPRING2016
11.05.23
Графы
Остовное дерево связного графа - ациклический  связный подграф(дерево), в который входят все вершины данного графа (в нем нет цикла вершин)
Сининимы - остов, покрывающее дерево, скелет графа
если граф взвешенный, то надо найти оставное дерево с минимальной суммой весов входящий в него ребер
ДЗ алгоритм Прима и Крускала
Применение: рассылка информации в сети, прокладка кабелей TV,
очередь с приоритетом - очередь, в которой элементы имеют приоритет, первым извлекаются элемент с наибольшим приоритетом
Двоичная куча - двоичное дерево, удоавлетворяющее условиям: 1) приоритет любой вершины не меньше приоритета потомков;
                                                            2) дерево является полным двоичным деревом
Система непересекающихся множеств - структура данных для представления непересекающихся множеств
операции:
1) MakeSet  - создать мнво
2) FindSet - номер мнва, которому принадлежит элемент i
3) UnionSet - объединение множеств





18.05.23
collection framework
iterable - базовый интерфейс у которого только 1 метод iterator()-2 метода hasnext, next




*/
// axo книга по структурам данных
// сейджвик разработка
// хорстман
// кормен
// кнут
